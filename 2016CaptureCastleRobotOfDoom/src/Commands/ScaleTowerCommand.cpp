// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "ScaleTowerCommand.h"

static const int HALFREVS_MAX = 29;
static const float CLIMB_SPEED = 1;

ScaleTowerCommand::ScaleTowerCommand() {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// Called just before this Command runs the first time
void
ScaleTowerCommand::Initialize() {
	//time(&lastTime);
	//time(&currentTime);
	lastRevState = RobotMap::heightCounter->Get();
	iterations = 0;
	// release arm raising clips
	RobotMap::armsUpAndOut->Set(Relay::Value::kForward);
}

// Called repeatedly when this Command is scheduled to run
void
ScaleTowerCommand::Execute() {
	if (lastRevState != RobotMap::heightCounter->Get()) {
		if (lastRevState) {
			halfrevs++;
		}
		lastRevState = !lastRevState;
	}
	if (iterations > 250) {
		// after the first revolution is complete, turn off the arm clip motors.
		RobotMap::armsUpAndOut->Set(Relay::Value::kOff);
	}
	iterations++;
	if (halfrevs < HALFREVS_MAX) {
		RobotMap::scaleTower->Set(CLIMB_SPEED);
		DriverStation::ReportWarning("Half Revs: " + std::to_string(halfrevs));
		//DriverStation::ReportWarning("heightCounter: " + std::to_string(RobotMap::heightCounter->Get()));
	} else {
		RobotMap::scaleTower->StopMotor();
	}
	//dt = difftime(time(&currentTime) , lastTime);
	//time (&lastTime);
	//double acceleration = Robot::robot->getAcceleration() * GRAVITY;
	//velocity += acceleration * dt; // v = v0 + a * t
	//distanceTravelled += velocity * dt + acceleration * dt * dt; // d = d0 + v0*t + a*t^2
	//counter += RobotMap::heightCounter->GetTriggerState() ? 1 : 0;
}

// Make this return true when this Command no longer needs to run execute()
bool
ScaleTowerCommand::IsFinished() {
	return false;
}

// Called once after isFinished returns true
void
ScaleTowerCommand::End() {
	RobotMap::scaleTower->StopMotor();
	RobotMap::armsUpAndOut->Set(Relay::Value::kOff);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void
ScaleTowerCommand::Interrupted() {
	End();
}
