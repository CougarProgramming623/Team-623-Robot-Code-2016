// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
#include "AnalogGyro.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
SpeedController* RobotMap::robotDriveTreadRightFront = nullptr;
SpeedController* RobotMap::robotDriveTreadRightBack = nullptr;
SpeedController* RobotMap::robotDriveTreadLeftFront = nullptr;
SpeedController* RobotMap::robotDriveTreadLeftBack = nullptr;
SpeedController* RobotMap::ballShooterSpinnerClockwise = nullptr;
SpeedController* RobotMap::ballShooterSpinnerCounterclockwise = nullptr;
SpeedController* RobotMap::shooterAimingDevice = nullptr;
Relay* RobotMap::ballShooterSpinnerSpringWinder = nullptr;
Relay* RobotMap::armsUpAndOut = nullptr;
SpeedController* RobotMap::scaleTower = nullptr;

RobotDrive* RobotMap::robotDrive41 = nullptr;
PositionSubsystem* RobotMap::positionSubsystem = nullptr;

DigitalOutput* RobotMap::ultrasonicPing = nullptr;
AnalogInput* RobotMap::ultrasonicEcho = nullptr;
AnalogGyro* RobotMap::gyro = nullptr;

AnalogPotentiometer* RobotMap::potentiometer = nullptr;
BuiltInAccelerometer* RobotMap::accelerometer = nullptr;

DigitalInput* RobotMap::limitSpinnerSpringWinder = nullptr;
DigitalInput* RobotMap::limitSADPosBaseline = nullptr;
DigitalInput* RobotMap::heightCounter = nullptr;

DigitalInput* RobotMap::autoLowBar = nullptr;
DigitalInput* RobotMap::autoNotLowBar = nullptr;
DigitalInput* RobotMap::autoSpyBox = nullptr;
int RobotMap::autoSelector = -1;

#ifdef USE_TWO_REV_COUNTERS

DigitalInput* RobotMap::revCounterInputLeft = nullptr;
DigitalInput* RobotMap::revCounterInputRight = nullptr;
int RobotMap::revCounterLeft = 0;
int RobotMap::revCounterRight = 0;

#else

DigitalInput* RobotMap::revCounterInput = nullptr;
int RobotMap::revCounter = 0;
bool RobotMap::oldRevState = false;

#endif

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void
RobotMap::init() {
	CameraServer *camera = CameraServer::GetInstance();
	camera->SetQuality(25);
	camera->StartAutomaticCapture("cam1"); //If using 2015 robot use "cam0"     if using 2016 robot use ""

	autoLowBar = new DigitalInput(AUTO_LOW_BAR);
	autoSpyBox = new DigitalInput(AUTO_SPY_BOX);
	autoNotLowBar = new DigitalInput(AUTO_NOT_LOW_BAR);
	gyro = new AnalogGyro(PORT_GYRO);

	if(autoLowBar->Get()) {
		autoSelector = 0;
	}
	else if(autoLowBar->Get()) {
		autoSelector = 1;
	}
	else if(autoLowBar->Get()) {
		autoSelector = 2;
	}

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	LiveWindow* lw = LiveWindow::GetInstance();

	//NOTE: This is where you set the where the wire on RoboRIO goes

	//Sensors
	accelerometer = new BuiltInAccelerometer(BuiltInAccelerometer::Range::kRange_8G);
	potentiometer = new AnalogPotentiometer(PORT_POTENTIOMETER);
	ultrasonicPing = new DigitalOutput(PORT_ULTRASONIC_PING);
	ultrasonicEcho = new AnalogInput(PORT_ULTRASONIC_ECHO);

	//Limit
	limitSpinnerSpringWinder = new DigitalInput(L_SPINNER_SPRING_WINDER);
	limitSADPosBaseline = new DigitalInput(L_SAD_POS_BASELINE);

	//Counter
	heightCounter = new DigitalInput(HEIGHT_COUNTER);
#ifdef USE_TWO_REV_COUNTERS

	revCounterInputLeft = new DigitalInput(PORT_REV_COUNTER_LEFT);
	revCounterInputRight = new DigitalInput(PORT_REV_COUNTER_RIGHT);

#else

	revCounterInput = new DigitalInput(PORT_REV_COUNTER);
	oldRevState =  revCounterInput->Get();

#endif

	//Drive
	robotDriveTreadRightFront = new Talon(FRONT_RIGHT);
	lw->AddActuator("Robot Drive" , "treadRightFront" , (Talon*) robotDriveTreadRightFront);

	robotDriveTreadRightBack = new Talon(BACK_RIGHT);
	lw->AddActuator("Robot Drive" , "treadRightBack" , (Talon*) robotDriveTreadRightBack);

	robotDriveTreadLeftFront = new Talon(FRONT_LEFT);
	lw->AddActuator("Robot Drive" , "treadLeftFront" , (Talon*) robotDriveTreadLeftFront);

	robotDriveTreadLeftBack = new Talon(BACK_LEFT);
	lw->AddActuator("Robot Drive" , "treadLeftBack" , (Talon*) robotDriveTreadLeftBack);

	robotDrive41 = new RobotDrive(robotDriveTreadLeftFront , robotDriveTreadLeftBack , robotDriveTreadRightFront , robotDriveTreadRightBack);

	robotDrive41->SetSafetyEnabled(true);
	robotDrive41->SetExpiration(2);
	robotDrive41->SetSensitivity(0.5);
	robotDrive41->SetMaxOutput(1.0);
	robotDrive41->SetInvertedMotor(RobotDrive::kFrontLeftMotor , true);
	robotDrive41->SetInvertedMotor(RobotDrive::kRearLeftMotor , true);
	robotDrive41->SetInvertedMotor(RobotDrive::kFrontRightMotor , true);
	robotDrive41->SetInvertedMotor(RobotDrive::kRearRightMotor , true);

	//Ball Shooter
	shooterAimingDevice = new Talon(PORT_SAD);
	shooterAimingDevice->SetInverted(true);
	lw->AddActuator("Position Subsystem" , "SAD" , (Talon*) shooterAimingDevice);

	ballShooterSpinnerClockwise = new Talon(SPINNER_CW);
	lw->AddActuator("Position Subsystem" , "clockwise spinner" , (Talon*) ballShooterSpinnerClockwise);

	ballShooterSpinnerCounterclockwise = new Talon(SPINNER_CCW);
	lw->AddActuator("Position Subsystem" , "counterclockwise spinner" , (Talon*) ballShooterSpinnerCounterclockwise);

	ballShooterSpinnerSpringWinder = new Relay(SPINNER_SPRING_WINDER);
	lw->AddActuator("Position Subsystem" , "spinner spring winder" , (Relay*) ballShooterSpinnerSpringWinder);

	positionSubsystem = new PositionSubsystem();

	scaleTower = new Talon(SCALE_TOWER);
	lw->AddActuator("Scale Tower" , "Scale Tower" , (Relay*) scaleTower);

	armsUpAndOut = new Relay(ARMS_UP_AND_OUT);
	lw->AddActuator("MCL" , "lifter" , (Relay*) armsUpAndOut);

//	position->SetInverted(true);

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}

double
RobotMap::radianToPotentiometer(double radian) {
	return degreeToPotentiometer(radian * 180 / M_PI);
}

double
RobotMap::potentiometerToDegree(double potentiometer) {
	return potentiometer * 253 - 33.6;
}

double
RobotMap::potentiometerToRadian(double potentiometer) {
	return potentiometerToDegree(potentiometer) * M_PI / 180;
}

double
RobotMap::degreeToPotentiometer(double degree) {
	return (fmod(degree , 360) - 33.6) / 253;
}

double
RobotMap::getUlrasonicFeet() {
	RobotMap::ultrasonicPing->SetUpSourceEdge(false , true);
	Wait(.02);
	double distance = (ultrasonicEcho->GetVoltage() * 5000) / 1024 / .5;
	RobotMap::ultrasonicPing->SetUpSourceEdge(true , false);
	Wait(.02);
	return distance;
}

double
RobotMap::getUlrasonicMeters() {
	return getUlrasonicFeet() * .0348;
}
#ifdef USE_TWO_REV_COUNTERS

void
RobotMap::resetRevCounters() {
	revCounterLeft = 0;
	revCounterRight = 0;
}

void
RobotMap::updateRevCounters() {
	if(revCounterInputLeft->Get())
	revCounterLeft++;
	if(revCounterInputRight->Get())
	revCounterRight++;
}

double
RobotMap::getTotalDistanceTravelled() {
	return (getDistanceTravelledLeft() + getDistanceTravelledRight()) / 2;
}

double
RobotMap::getDistanceTravelledLeft() {
	return revCounterRight * METERS_PER_REV_LEFT;
}

double
RobotMap::getDistanceTravelledRight() {
	return revCounterRight * METERS_PER_REV_RIGHT;
}

#else

void
RobotMap::resetRevCounter() {
	revCounter = 0;
}

void
RobotMap::updateRevCounter() {
	DriverStation::ReportError(std::to_string(revCounterInput->Get()));
	bool revState = revCounterInput->Get();
	if(revState != oldRevState) {
		if(revState)
			revCounter++;
		oldRevState = revState;
	}
}

double
RobotMap::getDistanceTravelled() {				//	10 ft = 21.2 units on average
	return revCounter * FEET_PER_REV;
}

#endif
