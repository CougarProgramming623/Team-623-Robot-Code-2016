// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Robot.h"
#include "Subsystems/ButtonBoard.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
SubsystemDrive* Robot::subsystemDrive = NULL;
SubsystemInput* Robot::subsystemInput = NULL;
SubsystemBallShooter* Robot::subsystemBallShooter = NULL;
OI* Robot::oi = 0;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	subsystemDrive = new SubsystemDrive();
	subsystemInput = new SubsystemInput();
	subsystemBallShooter = new SubsystemBallShooter();

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi = new OI();
	lw = LiveWindow::GetInstance();

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	autonomousCommand = new AutonomousCommand();

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
}

double Robot::getPoteniometerValue() {
	return RobotMap::potentiometer->Get() - potentiometer_zero;
}

//Shoots a ball
void Robot::shoot() {
	subsystemBallShooter->spinnerCounterclockwise->Set(.5);
	subsystemBallShooter->spinnerClockwise->Set(.5);
	Wait(500);
	subsystemBallShooter->spinnerSpringWinder->Set(Relay::Value::kForward);
	while(!RobotMap::limitSpinnerSpringWinder->Get())
		;
	subsystemBallShooter->spinnerCounterclockwise->Set(0);
	subsystemBallShooter->spinnerClockwise->Set(0);
	subsystemBallShooter->spinnerSpringWinder->Set(Relay::Value::kReverse);
	while(RobotMap::limitSpinnerSpringWinder->Get())
		;
	subsystemBallShooter->spinnerSpringWinder->Set(Relay::Value::kOff);
}

//This turns the robot left or right with a specified power
void Robot::turnRobot(double power) { //-1 = Left 1 = Right
	subsystemDrive->treadLeftFront->Set(power);
	subsystemDrive->treadLeftBack->Set(power);
	subsystemDrive->treadRightFront->Set(power);
	subsystemDrive->treadLeftBack->Set(power);
}

//This turns the robot left or right with a specified power and and a specified degrees
void Robot::turnRobot(double power , double degrees) {
	turnRobot(power);
	float gyroRotation = RobotMap::robotMap->gyro->GetAngle();
	while(fmod(3600 + RobotMap::robotMap->gyro->GetAngle() - gyroRotation - degrees , 360) > 5)
		;
	stopRobot();
}

//Moves robot forward or backward with a specified power
void Robot::moveRobotLinear(double power) { // -1 = backward 1 = forwards
	subsystemDrive->treadLeftFront->Set(power);
	subsystemDrive->treadLeftBack->Set(power);
	subsystemDrive->treadRightFront->Set(power);
	subsystemDrive->treadLeftBack->Set(power);
}

//Moves robot forward or backward a specified distance
void Robot::moveRobotLinear(double power , double distance) { // in meters
	moveRobotLinear(power);
	time_t initTime , currentTime;
	time(&initTime);
	double distanceTravelled = 0 , velocity = 0 , seconds;
	while(distanceTravelled < distance) {
		seconds = difftime(initTime , time(&currentTime));
		time(&initTime);
		double acceleration = subsystemInput->accelerometer->GetAcceleration() * GRAVITY;
		velocity += acceleration * seconds; // v = v0 + a * t
		distanceTravelled += velocity * seconds + acceleration * seconds * seconds; // d = d0 + v0*t + a*t^2
	}
	stopRobot();
}

void Robot::stopRobot() {
	moveRobotLinear(0);	//This makes the robot to STOP
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit() {

}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	if(autonomousCommand != NULL)
		autonomousCommand->Start();

	RobotMap::shooterAimingDevice->Set(-1); // TODO: check direction

	while(!RobotMap::limitSADPosBaseline->Get()) {
	}

	potentiometer_zero = RobotMap::potentiometer->Get();
}

//Autonomous program (Look at notes for autonomous instructions)
void Robot::AutonomousPeriodic() {		//TODO: Write autonomous code
#if ROBOT_AUTO == 1
	turnRobot(-1 , 180);
	moveRobotLinear(1 , 1.85);
	turnRobot(1 , 90);
	moveRobotLinear(1 , 7.3);
	turnRobot(1 , 120);
	shoot();
#elif ROBOT_AUTO == 2

#endif
}

void Robot::TeleopInit() {
// This makes sure that the autonomous stops running when
// teleop starts running. If you want the autonomous to
// continue until interrupted by another command, remove
// these lines or comment it out.
	if(autonomousCommand != NULL)
		autonomousCommand->Cancel();
}

void Robot::TeleopPeriodic() {
	const double linear_threshold = .05;	//NOTE:Change if rotate speed too slow or too fast
	const double twist_threshold = .05;	//NOTE: Change if rotate speed too slow or too fast
	Scheduler::GetInstance()->Run();
//  Teleop Movement
	Joystick* joystick = oi->getJoystick1();
	double y = joystick->GetY() , twist = joystick->GetTwist();
	if(std::abs(y) > linear_threshold) {
		subsystemDrive->treadRightFront->Set(y);
		subsystemDrive->treadRightBack->Set(y);
		subsystemDrive->treadLeftFront->Set(y);
		subsystemDrive->treadLeftBack->Set(y);
	}
	if(std::abs(twist) > twist_threshold) {		//Left side of Robot already inverted (inverted in RobotBuilder)
		subsystemDrive->treadRightFront->Set(twist);
		subsystemDrive->treadRightBack->Set(twist);
		subsystemDrive->treadLeftFront->Set(-twist);
		subsystemDrive->treadLeftBack->Set(-twist);
	}

//The Button of the All Mighty Board of Buttons
	ButtonBoard* btnBoard = oi->getBtnBoard();
	if(btnBoard->getSADUp()) {
		subsystemBallShooter->spinnerCounterclockwise->Set(0);
		subsystemBallShooter->spinnerClockwise->Set(0);
		if(subsystemInput->potentiometer->Get() > SAD_UP_POT) {
			subsystemBallShooter->shooterAimingDevice->Set(1);
		}
		else if(subsystemInput->potentiometer->Get() < SAD_UP_POT) {
			subsystemBallShooter->shooterAimingDevice->Set(-1);
		}
	}

	if(btnBoard->getSADDown()) {
		if(subsystemInput->potentiometer->Get() > SAD_DOWN_POT) {
			subsystemBallShooter->spinnerCounterclockwise->Set(0);
			subsystemBallShooter->spinnerClockwise->Set(0);
			subsystemBallShooter->shooterAimingDevice->Set(1);
		}
		else if(subsystemInput->potentiometer->Get() < SAD_DOWN_POT) {
			subsystemBallShooter->spinnerCounterclockwise->Set(0);
			subsystemBallShooter->spinnerClockwise->Set(0);
			subsystemBallShooter->shooterAimingDevice->Set(-1);
		}
		else {
			subsystemBallShooter->spinnerClockwise->Set(1);
			subsystemBallShooter->spinnerCounterclockwise->Set(1);
		}
	}

	if(btnBoard->getShoot()) {
		shoot();
	}
	if(btnBoard->getPos() != POS_NONE) {
		// TODO: Find values for potentiometers and replace 0s
		float newValue = RobotMap::potentiometer->Get();
		switch(btnBoard->getPos()) {
			case POS_OBSTACLE:
				newValue = 0;
				break;
			case POS_BALL_PICKUP:
				newValue = 0;
				break;
			case POS_DEFAULT:
				newValue = 0;
				break;
			case POS_SHOOTING:
				newValue = 0;
				break;
			case POS_SAFTEY:
				newValue = 0;
				break;
		}
		float currentValue = RobotMap::potentiometer->Get();
		float power = newValue - currentValue;
		if(power != 0) {
			RobotMap::position->Set(power);
			//TODO: Potentiometer value check
		}
	}
	if(btnBoard->getLifterPos() != LIFTER_POS_NONE) {
		float newValue = RobotMap::potentiometer->Get();
		switch(btnBoard->getLifterPos()) {
			case LIFTER_POS_RELEASE:
				newValue = 0;
				break;
			case LIFTER_POS_UP:
				newValue = 0;
				break;
			case LIFTER_POS_DOWN:
				newValue = 0;
				break;
		}
		float currentValue = RobotMap::potentiometer->Get();
		float power = newValue - currentValue;
		if(power < 0)
			power = -1;
		else if(power > 0)
			power = 1;

		else
			power = 0;
		RobotMap::lifter->Set(Relay::Value::kForward);

		time_t initTime , currentTime;
		time(&initTime);

		int counter = 0;
		double distanceTravelled = 0 , velocity = 0 , seconds;
		while(distanceTravelled < 1.75) { // 1.75 m
			seconds = difftime(initTime , time(&currentTime));
			time(&initTime);
			double acceleration = subsystemInput->accelerometer->GetAcceleration() * GRAVITY;
			velocity += acceleration * seconds; // v = v0 + a * t
			distanceTravelled += velocity * seconds + acceleration * seconds * seconds; // d = d0 + v0*t + a*t^2
			counter += RobotMap::heightCounter->GetTriggerState() ? 1 : 0;
			if(counter >= MAX_REVOLUTIONS)
				break;
		}
		RobotMap::lifter->Set(Relay::Value::kOff);
	}
//	DriverStation::ReportError("Y: "  + std::to_string(y) + "   Twist: " + std::to_string(twist) + "\n"); //OLD: Used for making sure the wheels are set correctly
//	DriverStation::ReportError("Potentiometer: " + std::to_string(subsystemInput->potentiometer->Get()) + "\n"); //Used to test Potentiometer
}

void Robot::TestPeriodic() {
	lw->Run();
}

//START_ROBOT_CLASS(Robot);

